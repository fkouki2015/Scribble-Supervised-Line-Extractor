import os
import shutil
import numpy as np
from fastapi import FastAPI, File, UploadFile, Form
from fastapi.responses import FileResponse
from line_extract import predict_line, compute_frangi_response, apply_frangi_percentile
from fastapi.middleware.cors import CORSMiddleware
import cv2

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

image_path : str = None
scr_path : str = None
frangi_path : str = None
refined_scr_path : str = None
line_path : str = None


# 一時ファイルの保存ディレクトリ
os.makedirs("temp", exist_ok=True)

def save_file(upload_file: UploadFile, destination: str):
    """アップロードされたファイルを指定したパスに保存する"""
    with open(destination, "wb") as f:
        shutil.copyfileobj(upload_file.file, f)


def _resize_to_max(img, max_size: int, interpolation):
    h, w = img.shape[:2]
    s = max(h, w)
    if s <= int(max_size):
        return img
    scale = float(max_size) / float(s)
    new_w = int(round(w * scale))
    new_h = int(round(h * scale))
    return cv2.resize(img, (new_w, new_h), interpolation=interpolation)


def save_image_upload(upload_file: UploadFile, destination: str, *, max_size: int | None = None, interpolation=cv2.INTER_AREA, target_wh=None):
    """Save an uploaded image to destination, optionally resizing.

    - If target_wh=(w,h) is provided, the image is resized exactly to that size.
    - Else if max_size is provided, the image is resized so max(h,w) <= max_size.
    """
    data = upload_file.file.read()
    arr = cv2.imdecode(np.frombuffer(data, np.uint8), cv2.IMREAD_UNCHANGED)
    if arr is None:
        raise ValueError("Failed to decode uploaded image")
    if target_wh is not None:
        w, h = target_wh
        arr = cv2.resize(arr, (int(w), int(h)), interpolation=interpolation)
    elif max_size is not None:
        arr = _resize_to_max(arr, int(max_size), interpolation=interpolation)
    cv2.imwrite(destination, arr)
    return arr

# @app.post("/api/refine_scribble")
# async def api_refine_scribble(
#     image: UploadFile = File(...),
#     scribble: UploadFile = File(...),
#     use_clahe: bool = Form(False),
#     clahe_clip: float = Form(2.0),
#     clahe_grid: int = Form(8),
#     max_size: int = Form(5000),
#     frangi_percentile: float = Form(99.7),
# ):
#     req_id = str(uuid.uuid4())
#     img_path = f"temp/img.png"
#     scr_path = f"temp/scr.png"
    
#     save_file(image, img_path)
#     save_file(scribble, scr_path)
    
#     refined_scr_u8 = refine_scribble(
#         img_path,
#         scr_path,
#         use_clahe,
#         clahe_clip,
#         clahe_grid,
#         max_size,
#         frangi_percentile,
#     )

#     refined_scr_path = f"temp/scr_refined.png"
#     cv2.imwrite(refined_scr_path, refined_scr_u8)

#     if os.path.exists(refined_scr_path):
#         return FileResponse(refined_scr_path, media_type="image/png")
#     else:
#         return {"error": "Output not generated by line_extract.py"}


@app.post("/api/compute_frangi")
async def api_compute_frangi(
    image: UploadFile = File(...),
    scribble: UploadFile = File(...),
    use_clahe: bool = Form(False),
    clahe_clip: float = Form(2.0),
    clahe_grid: int = Form(8),
    max_size: int = Form(5000),
):
    img_path = "temp/img.png"
    scr_path = "temp/scr.png"

    save_image_upload(image, img_path, max_size=max_size, interpolation=cv2.INTER_AREA)
    save_image_upload(scribble, scr_path, max_size=max_size, interpolation=cv2.INTER_NEAREST)

    response_bgr = compute_frangi_response(
        img_path, scr_path, use_clahe, clahe_clip, clahe_grid, max_size
    )

    frangi_path = "temp/frangi.png"
    cv2.imwrite(frangi_path, response_bgr)
    return FileResponse(frangi_path, media_type="image/png")


@app.post("/api/apply_frangi_percentile")
async def api_apply_frangi_percentile(
    # frangi_image: UploadFile = File(...),
    # scribble: UploadFile = File(...),
    percentile: float = Form(99.0),
):
    frangi_path = "temp/frangi.png"
    scr_path = "temp/scr.png"

    refined_bgr = apply_frangi_percentile(frangi_path, scr_path, percentile)

    refined_path = "temp/scr_refined.png"
    cv2.imwrite(refined_path, refined_bgr)
    return FileResponse(refined_path, media_type="image/png")


@app.post("/api/predict_line")
async def api_predict_line(
    image: UploadFile = File(...),
    scribble: UploadFile = File(...),
    refined_scribble: UploadFile = File(...),
    lr: float = Form(1e-3),
    iters: int = Form(1000),
    device: str = Form("cuda"),
    max_size: int = Form(5000)
):

    img_path = "temp/img.png"
    scr_path = "temp/scr.png"
    refined_scr_path = "temp/scr_refined.png"

    # Resize at save-time so all subsequent processing uses aligned resolutions.
    img_arr = save_image_upload(image, img_path, max_size=max_size, interpolation=cv2.INTER_AREA)
    save_image_upload(scribble, scr_path, max_size=max_size, interpolation=cv2.INTER_NEAREST)

    predicted_line = predict_line(img_path, scr_path, refined_scr_path, lr, iters, device, max_size)

    line_path = f"temp/line.png"
    cv2.imwrite(line_path, predicted_line)

    if os.path.exists(line_path):
        return FileResponse(line_path, media_type="image/png")
    else:
        return {"error": "Output not generated by line_extract.py"}



if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8000)