import os
import shutil
import numpy as np
from fastapi import FastAPI, File, UploadFile, Form
from fastapi.responses import FileResponse
from line_extract import predict_line, compute_frangi_response, apply_frangi_percentile, refine_scribble
from fastapi.middleware.cors import CORSMiddleware
import cv2

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

img_path : str = "temp/img.png"
scr_path : str = "temp/scr.png"
frangi_path : str = "temp/frangi.png"
refined_scr_path : str = "temp/scr_refined.png"
line_path : str = "temp/line.png"


# 一時ファイルの保存ディレクトリ
os.makedirs("temp", exist_ok=True)

def save_file(upload_file: UploadFile, destination: str):
    """アップロードされたファイルを指定したパスに保存する"""
    with open(destination, "wb") as f:
        shutil.copyfileobj(upload_file.file, f)


def _resize_to_max(img, max_size: int, interpolation):
    h, w = img.shape[:2]
    s = max(h, w)
    if s <= int(max_size):
        return img
    scale = float(max_size) / float(s)
    new_w = int(round(w * scale))
    new_h = int(round(h * scale))
    return cv2.resize(img, (new_w, new_h), interpolation=interpolation)


def save_image_upload(upload_file: UploadFile, destination: str, *, max_size: int | None = None, interpolation=cv2.INTER_AREA, target_wh=None):
    """Save an uploaded image to destination, optionally resizing.

    - If target_wh=(w,h) is provided, the image is resized exactly to that size.
    - Else if max_size is provided, the image is resized so max(h,w) <= max_size.
    """
    data = upload_file.file.read()
    arr = cv2.imdecode(np.frombuffer(data, np.uint8), cv2.IMREAD_UNCHANGED)
    if arr is None:
        raise ValueError("Failed to decode uploaded image")
    if target_wh is not None:
        w, h = target_wh
        arr = cv2.resize(arr, (int(w), int(h)), interpolation=interpolation)
    elif max_size is not None:
        arr = _resize_to_max(arr, int(max_size), interpolation=interpolation)
    cv2.imwrite(destination, arr)
    return arr



@app.post("/api/compute_frangi")
async def api_compute_frangi(
    image: UploadFile = File(...),
    use_clahe: bool = Form(False),
    clahe_clip: float = Form(2.0),
    clahe_grid: int = Form(8),
    max_size: int = Form(5000),
):
    
    save_image_upload(image, img_path, max_size=max_size, interpolation=cv2.INTER_AREA)

    response_bgr = compute_frangi_response(
        img_path, use_clahe, clahe_clip, clahe_grid, max_size
    )

    cv2.imwrite(frangi_path, response_bgr)
    return FileResponse(frangi_path, media_type="image/png")


@app.post("/api/apply_frangi_percentile")
async def api_apply_frangi_percentile(
    # frangi_image: UploadFile = File(...),
    # scribble: UploadFile = File(...),
    percentile: float = Form(99.0),
):

    refined_bgr = apply_frangi_percentile(frangi_path, percentile, img_path=img_path)

    cv2.imwrite(refined_scr_path, refined_bgr)
    return FileResponse(refined_scr_path, media_type="image/png")



@app.post("/api/refine_scribble")
async def api_refine_scribble(
    image: UploadFile = File(...),
    scribble: UploadFile = File(...),
    use_clahe: bool = Form(False),
    clahe_clip: float = Form(2.0),
    clahe_grid: int = Form(8),
    max_size: int = Form(5000),
):

    save_image_upload(image, img_path, max_size=max_size, interpolation=cv2.INTER_AREA)
    save_image_upload(scribble, scr_path, max_size=max_size, interpolation=cv2.INTER_NEAREST)

    refined_bgr = refine_scribble(
        img_path,
        scr_path,
        use_clahe,
        clahe_clip,
        clahe_grid,
        max_size,
    )
    
    cv2.imwrite(refined_scr_path, refined_bgr)
    return FileResponse(refined_scr_path, media_type="image/png")


@app.post("/api/predict_line")
async def api_predict_line(
    lr: float = Form(1e-3),
    iters: int = Form(1000),
    device: str = Form("cuda"),
    max_size: int = Form(5000)
):


    # Resize at save-time so all subsequent processing uses aligned resolutions.
    # img_arr = save_image_upload(image, img_path, max_size=max_size, interpolation=cv2.INTER_AREA)
    # save_image_upload(scribble, scr_path, max_size=max_size, interpolation=cv2.INTER_NEAREST)

    predicted_line = predict_line(img_path, scr_path, refined_scr_path, lr, iters, device, max_size)

    cv2.imwrite(line_path, predicted_line)

    if os.path.exists(line_path):
        return FileResponse(line_path, media_type="image/png")
    else:
        return {"error": "Output not generated by line_extract.py"}



if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8000)